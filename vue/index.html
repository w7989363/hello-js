<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>Vue</title>
  <!-- 如果是直接引用 Vue 而不是通过 webpack 等工具构建，则在生产环境中需要引用 .min.js 版本来取消警告信息 -->
  <!-- webpack 中则是根据 process.env.NODE_ENV 来决定是否启用生产环境模式 -->
  <script src="https://cdn.jsdelivr.net/npm/vue"></script>

  <style>
    .demo-alert-box {
      padding: 10px 20px;
      background: #f3beb8;
      border: 1px solid #f09898;
    }
    body > div{
      padding: 10px 0;
      border-bottom: 1px solid #aaa;
    }
  </style>
</head>

<body>
  <!-- v-bind -->
  <!-- v-bind缩写 :title="mytitle" 绑定class时还可以传入对象或数组 -->
  <!-- isActive为true时，div有active类 -->
  <div id="app" v-bind:title="mytitle" :class="{ active: isActive }">
    <!-- mustache语法会将值解释为文本，即使他是一段html -->
    <p>mustache语法 : {{ message }}</p>
    <!-- v-html 指令可以将值解释为html代码，注意不要对用户提供的内容进行渲染以导致xss攻击 -->
    <p>v-html指令 : <span v-html="message"></span></p>
    <!-- v-pre 跳过这个元素及其子元素的编译过程，显示原始mustache标签 -->
    <p v-pre>{{ this will not be compiled }}</p>
    <!-- v-once指令只会初次渲染，之后改变数据值不会更新，这会创建低开销的有缓存的静态组件 -->
    <p v-once>这里的值不会随message而改变 : {{message}}</p>
    <!-- v-cloak 指令会保持在元素上，直到关联实例结束编译 -->
    <!-- 添加 css 规则 [v-cloak] { display: none } 可以隐藏未编译的mustache -->
  </div>
  <script>
    // 启用chrome vue devtools
    Vue.config.devtools = true;
    // v-bind
    let app = new Vue({
    	el: '#app',
    	data: {
    		message: '<span style="color:red">This should be red.</span>',
    		mytitle: '页面加载于 ' + new Date().toLocaleString(),
    		isActive: true,
    	}
    })
    // Vue 执行异步 DOM 更新，在一个事件循环中收集所有变化
    // 对所有更新去重之后计算实际的变化，在下一次事件循环中更新 DOM
    // 因此更改一个属性之后，只有 VNode 的数据立即更新了，
    app.isActive = false
    app.isActive === false // true
    // 但是 DOM 并没有立即响应式更新
    app.$el.className === 'active' // true
    // 可以使用 vm.$nextTick() 放到下一个事件循环
    app.$nextTick(function() {
      app.$el.className === '' // true
    })
    // 也可以使用 async await
    // 更新数据后，await 一个空的 $nextTick()，后面 DOM 就已经更新了

  </script>


  <!-- v-if v-else v-else-if -->
  <div id="app-2">
    <p v-if="seen">能看到</p>
    <p v-else>看不到</p>
  </div>
  <script>
    // v-if
    let app2 = new Vue({
    	el: '#app-2',
    	data: {
    		seen: false,
    	}
    });
    // v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
    // v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
    // 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS display 进行切换。
    // 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。
    // 因此，如果需要非常频繁地切换，则使用 v-show 较好；
    // 如果在运行时条件很少改变，则使用 v-if 较好
  </script>


  <!-- v-for="(item, index) in array" 或者用 of 代替 in -->
  <!-- v-for="(value, key, index) in object" -->
  <!-- 对象的遍历是按照Object.keys()的结果进行的 -->
  <!-- 用 v-bind:key="uniqueKey" 来让Vue跟踪每个节点的身份 -->
  <!-- v-for:"n in 10"  1~10 -->
  <!-- v-for 和 v-if 在同级时，for 优先级高，if会在每个for中执行 -->
  <div id="app-3">
    <ol>
      <li v-for="todo in todos">
        {{ todo }}
      </li>
    </ol>
  </div>
  <script>
    // v-for
    let app3 = new Vue({
    	el: '#app-3',
    	data: {
        todos: [
          '学习 JavaScript',
          '学习 Vue',
          '学习 React'
        ]
    	}
    });
    // 注意:
    // 利用索引直接设置数组项时 app3.todos[0] = 'another' 不能触发重渲染
    // 修改数组长度 app3.todos.length = 2 不能触发重渲染
    // 对象添加、删除属性不能触发重渲染，新添加的属性不是响应式的(因为属性在实例初始化的时候转换为 getter/setter)
    // 解决:
    // vm.$set(vm.todos, indexOfItem, newValue)
    // 修改数组长度可以使用 splice 函数
    // 给对象添加属性可以使用 vm.$set(obj, key, value)
  </script>


  <!-- v-on 监听事件 -->
  <!-- v-on缩写 @click="reverse" -->
  <div id="app-4">
    <p> {{ message }} </p>
    <!-- 可以使用 $event 为函数注入事件参数 -->
    <button
      type="button"
      name="button"
      v-on:click="reverse($event)"
      v-bind:disabled="isDisabled">
      倒置
    </button>
  </div>
  <script>
    // v-on
    let app4 = new Vue({
    	el: '#app-4',
    	data: {
    		message: 'Hello Vue.',
    		isDisabled: false,
    	},
    	methods: {
    		reverse: function(event) {
    			this.message = this.message.split('').reverse().join('');
    		},
    	},
    });
    // html 是大小写不敏感的，因此 @myEvent 会变为 @myevent，所以事件命名推荐使用 kebab-case
  </script>


  <!-- v-model表单输入绑定 watch侦听属性-->
  <div id="app-5">
    <p>total: {{ total }} </p>
    num: <input type="number" v-model="num" value="" />
    <br/>
    <select v-model="selected">
            <option disabled value="">请选择</option>
            <option value="a">A</option>
            <option value="b">B</option>
            <option value="c">C</option>
        </select>
    <span>Selected: {{ selected }}</span>
  </div>
  <script>
    // v-model watch侦听属性，需要在数据变化时执行异步操作或开销较大的操作时，使用watch
    let app5 = new Vue({
    	el: '#app-5',
    	data: {
    		num: 5,
    		total: 50,
    		selected: ''
    	},
    	watch: {
    		num: function(newVal, oldVal) {
    			this.total = newVal * 10;
    		}
    	}
    });
  </script>


  <!-- computed 计算属性-->
  <div id="app-7">
    <p>message: {{message}}</p>
    <p>reverseMessage: {{reverseMessage}}</p>
  </div>
  <script>
    // computed
    // 计算属性基于他们的依赖进行结果的缓存，只要依赖不改变，多次访问就会直接返回结果
    // 而如果用methods，则需要每次都执行方法返回结果
    // 上面的watch例子用computed改写更好
    let app7 = new Vue({
    	el: '#app-7',
    	data: {
    		message: 'hello',
    	},
    	computed: {
    		reverseMessage: function() {
    			return this.message.split('').reverse().join('');
    		},
    		// 双向绑定的计算属性，常用语 v-model 配合 Vuex 使用
    		someData: {
    			get() {
    				// 如果是从 Vuex store 中取
    				// return this.$store.state.someData
    			},
    			set(value) {
    				// 不能直接修改 Vuex 中的 state，所以发送 commit/dispatch
    				// this.$store.commit('updateSomeData', value);
    			}
    		}
    	}
    });
  </script>


  <!-- 组件的 v-for ，不能将item自动注入组件，需要使用props -->
  <div id="todo-list">
    <form @submit.prevent="addNewTodo">
      <label for="new-todo">Add a todo</label>
      <input v-model="newTodoText" type="text" id="new-todo" placeholder="E.g. Feed the cat">
      <button>Add</button>
    </form>
    <ul>
      <!-- 因为只有li才能直接出现在ul内部，如果直接使用todo-item标签会解析出错，因此用is指定模板 -->
      <li is="todo-item" v-for="(todo, index) in todos" :key="todo.id" :title="todo.title" @remove="todos.splice(index,1)"></li>
    </ul>
  </div>
  <script>
    Vue.component('todo-item', {
      template: `<li>{{title}} <button @click="$emit('remove')">Remove</button> </li>`,
      props: ['title'],
    });

    let todoList = new Vue({
      el: '#todo-list',
      data: {
        newTodoText: '',
        todos: [{
            id: 1,
            title: 'Do the dishes'
          },
          {
            id: 2,
            title: 'Take out the trash'
          },
          {
            id: 3,
            title: 'Mow the lawn'
          },
        ],
        nextTodoId: 4,
      },
      methods: {
        addNewTodo: function() {
          this.todos.push({
            id: this.nextTodoId++,
            title: this.newTodoText,
          });
          this.newTodoText = ''
        },
      },
    });
  </script>

  <!-- 事件修饰符 可以串联，可以只有修饰符-->
  <!-- @click.stop="doThis" 阻止事件继续传播 -->
  <!-- @submit.prevent="onSubmit" 提交事件不再重载页面 阻止默认事件 相当于调用preventDefault()-->
  <!-- @click.capture="doThis" 在事件捕获阶段处理 -->
  <!-- @click.self="doThat" event.target是当前元素时触发处理函数 -->
  <!-- @click.once="doThis" 点击事件只触发一次 -->
  <!-- @scroll.passive="onScroll"  相当于addEventListener中的passive选项， -->
  <!-- 告诉浏览器在事件处理函数中不会调用preventDefault()，以提升滚动性能 -->
  <!-- @input.native .native 修饰符一般用在组件上，希望监听组件根元素的原生 input 事件 -->

  <!-- 按键修饰符 .keyCode 或 .别名 -->
  <!-- @keyup.enter="submit"  -->
  <!-- 自带别名 .tab .delete .esc .space .up .down .left .right -->
  <!-- 自定义按键修饰符别名 Vue.config.keyCodes.f1 = 112 -->

  <!-- 系统修饰键 仅在按下相应按键时才触发鼠标或键盘事件的监听器 -->
  <!-- @keyup.alt.67  alt+c -->
  <!-- @click.ctrl="doSomething"  ctrl+click -->
  <!-- .ctrl .alt .shift .meta -->
  <!-- .exact 为精确模式，不能按下别的系统键 -->

  <!-- 鼠标按键修饰符 .left .right .middle -->
  <!-- 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 -->

  <!-- v-model.lazy="msg" 使用change事件对数据进行同步，而不是默认的input事件 -->
  <!-- v-model.number="age" 自动转换为数值类型 -->
  <!-- v-model.trim="msg" 自动过滤首尾空白符 -->

  <!-- v-bind:prop.sync="myProp" .sync 修饰符是语法糖 -->
  <!-- 当子组件中 prop 发生变化时，会通知父组件中同时更新 myProp -->
  <!-- 我们也可以使用 v-bind.sync="obj" 将一个对象中的所有属性都设置为 "双向绑定的" -->

  <script>
  // 由于 JavaScript 的限制，Vue 不能检测以下变动的数组：
  // 1.当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue
  // 2.当你修改数组的长度时，例如：vm.items.length = newLength
  // 解决：
  // 1.Vue.set() vm.$set(vm.array, index, value) 或用 splice
  // 2.vm.items.splice(newLength)

  // 还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：
  // 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性，即data里面直接定义的属性
  // 可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性 Vue.set(vm.obj, key, value)
  // 使用Object.assign()添加多个属性时，应该新建对象赋值给原对象，如下
  // vm.obj = Object.assign({}, vm.obj, {newkey1:newvalue1, newkey2:newvalue2})


  // 生命周期钩子
  // mounted() 不能保证所有子组件都挂载，可以使用 this.$nextTick() 代替mounted()
  // mounted() {
  //   this.$nextTick(function () {
  //     // Code that will run only after the
  //     // entire view has been rendered
  //   })
  // }

  // updated() 不会承诺所有的子组件也都一起被重绘，可以用 vm.$nextTick() 替换掉 updated()
  // updated() {
  //   this.$nextTick(function () {
  //     // Code that will run only after the
  //     // entire view has been re-rendered
  //   })
  // }

  // activated() <keep-alive>组件被激活时调用
  // deactivated() keep-alive组件失活时调用
  </script>


  <div id="button-counter-demo">
    <button-counter v-bind="test"></button-counter>
    <button-counter></button-counter>
    <button-counter></button-counter>
  </div>
  <script>
    Vue.config.devtools = true;
    // 全局注册组件，一个组件只能有一个根元素，组件名字母全小写且必须包含一个连字符
    Vue.component('button-counter', {
    	props: ['a', 'b'],
    	// 组件的data必须是函数，每个组件实例维护一份独立的数据
    	data: function() {
    		return {
    			count: 0
    		}
    	},
    	template: '<button v-on:click="count++">You clicked me {{ count }} times. {{a}},{{b}}</button>'
    });
    let buttonCounterDemo = new Vue({
    	el: '#button-counter-demo',
    	data: {
    		test: {
    			a: 1,
    			b: 2
    		}
    	}
    });

    // 局部注册组件
    // 如果不再使用某个全局注册的组件，它始终会包含在构建结果中增加js体积
    // 用对象定义组件
    // var ComponentA = { /* ... */ }
    // var ComponentB = { /* ... */ }
    // var ComponentC = { /* ... */ }
    // 然后在components选项中定义需要的组件，注意平级组件之间不可相互调用
    // new Vue({
    //     el: '#app'
    //     components: {
    //         'component-a': ComponentA,
    //         'component-b': ComponentB
    //     }
    // })

    // 如果在ComponentB.js中使用ComponentA和ComponentC
    // ComponentB.js如下
    // import ComponentA from './ComponentA'
    // import ComponentC from './ComponentC'
    //
    // export default {
    //     components: {
    //         ComponentA,
    //         ComponentC
    //     },
    //     // ...
    // }

    // 基础组件自动化全局注册https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C

    // 可以为使用的组件添加一个 ref 属性 <base-input ref="usernameInput"></base-input>
    // 然后使用 this.$refs.usernameInput 来访问这个子组件。可以调用这个组件中的方法 使用组件的变量
    // $refs 在渲染完成后生效，并且不是响应式的，因此不要再模板和 computed 中使用它
    </script>

  <!-- 通过 v-bind props 向子组件传递数据  -->
  <!-- @enlarge-text="onEnlargeText" 监听组件内部触发的事件，可通过$event访问到传递的参数 -->
  <div id="blog-post-demo">
    <div :style="{ fontSize: postFontSize+'em'}">
      <blog-post v-for="post in posts" :key="post.id" :post="post" @enlarge-text="onEnlargeText"></blog-post>
    </div>
  </div>
  <script>
    // 通过props向子组件传递数据
    Vue.component('blog-post', {
    	props: ['post'],
    	// 通过$emit(name, arg)向父级组件发送一个事件，事件名推荐使用kebab-case
    	template: `
        <div id="custom-input-demoblog-post">
            <h3>{{post.title}}</h3>
            <button @click="$emit('enlarge-text', 0.1)">Enlarge text</button>
            <div v-html="post.content"></div>
        </div>`,
    });
    let blogPostDemo = new Vue({
    	el: '#blog-post-demo',
    	data: {
    		posts: [{
    				id: 1,
    				title: 'My journey with Vue',
    				content: '...content...'
    			},
    			{
    				id: 2,
    				title: 'Blogging with Vue',
    				content: '...content...'
    			},
    			{
    				id: 3,
    				title: 'Why Vue is so fun',
    				content: '...content...'
    			}
    		],
    		postFontSize: 1,
    	},
    	methods: {
    		onEnlargeText: function(enlargeAmount) {
    			this.postFontSize += enlargeAmount;
    		}
    	}
    });
    // 如果想将一个对象中的所有属性都单个传入组件，例如
    // myobj: {
    //   id: 12,
    //   name: 'wtl'
    // }
    // 可以使用不带参数的 v-bind 
    // <component v-bind="myobj"></component>
    // 等价于
    // <component :id="myobj.id" :name="myobj.name"></component>

    // 通过props传递数据，数据流是单向的，只能由父组件到子组件
    // 如果想要实现双向绑定，可以用 .sync 修饰符
    // v-bind:name.sync="myName"  v-bind.sync="obj"
    // 然后在子组件中，发送一个update事件 this.$emit('upodate:name', newVal);


    // props中的变量名出现在html属性中，而属性不区分大小写，所以用kebab-case(短横线分隔)命名
    // 可以指定变量的类型、验证要求，没有满足要求会在控制台发出警告
    // props: {
    // 	propA: {
    //    类型，可以是数组 [Number, String, Array, Date, Function, Symbol, Boolean, Object]
    //    也可以是自定义类
    //    type: Number,
    // 		required: true, // 必填字段
    // 		default: 100, // 默认值，如果是对象、数组，必须从一个函数返回
    // 		validator: function(value) {
    // 			// 自定义验证函数，value必须是数组中的一个
    // 			// 验证失败时，开发环境下在控制台产生警告
    // 			// props会在实例创建之前进行验证，所以validator和default里不能用data、computed等
    // 			return ['success', 'warning', 'danger'].indexOf(value) !== -1;
    // 		}
    // 	},
    // }

    // props 会在组件实例创建之前进行验证，所以实例属性例如 data computed 在 default validator 中是不可用的

    // 不应该在一个子组件内部修改prop的值，最好定义一个本地data属性接受prop传来的初始值，然后改变data中的值
    // 数组、对象通过引用传入，直接赋值再修改还是会导致父组件内容被修改
  </script>

  <!-- 在组件上使用 v-model 以及 $attrs $listeners 的作用 -->
  <div id="custom-input-demo">
    <!-- placeholder 没有在 props 中接受，默认情况下会被组件的根元素 label 继承 -->
    <!-- 如果设置了 inherritAttrs=false 后 组件的根元素 label 就不会默认继承 placeholder  -->
    <!-- 而子元素 input 有 v-bind="$attrs" 所以 placeholder 属性会被组件内的 input 继承 -->
    <!-- 如果我们想监听根元素的原生事件，可以加修饰符 .native 但是本例中并不是想监听 label 元素的事件 -->
    <!-- 所以需要使用 $listeners 变量来实现 -->
    <custom-input
      v-model="searchText"
      :label="label"
      @input="console.log(event.target.value)"
      @focus="console.log('focus event')"
      placeholder="input and check console">
    </custom-input>
    <p>{{searchText}}</p>
    <custom-checkbox v-model="foo" value="some value"></custom-checkbox>
  </div>
  <script>
    // 在组件中使用v-model
    // <input v-model="searchText">
    // 等价于
    // <input :value="searchText" @input="searchText = $event.target.value">
    // 而用在组件上时， v-model则会这样
    // <custom-input :value="searchText" @input="searchText = $event"></custom-input>
    // 为了让其正常工作，这个组件内的input必须：
    // 1.将其 value 属性绑定到一个名叫 value 的 prop 上
    // 2.在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出
    Vue.component('custom-input', {
    	// 默认情况下，不被props识别的属性将会自动继承到组件的根元素上，设置为false时，根元素将不会继承这些属性
    	inheritAttrs: false,
    	props: ['label', 'value'],
      // $attrs 保存了传入组件的不被 props 识别的属性
    	// 使用 v-bind="$attrs" 可以在非根元素上继承不被props识别的属性(一般配合inheritAttrs:false使用)
    	// input不是根元素，所以想在 custom-input 标签中监听输入框的原生事件(例如input)时使用$listeners
    	template: `
        <label>
          {{label}}
          <input v-bind="$attrs" :value="value" v-on="myListeners" />
        </label>`,
      // $listeners 包含的是组件上监听的的非 .native 事件
      // 另外有的加了 .native 的事件并不是根元素所拥有的事件，也会包含在 $listeners 中
      // 此例中 组件根元素是 label 但是我们想监听的是 input 元素的 focus 和 input 事件
      // 所以我们可以定义一个 computed 计算属性，将想要监听的自定义事件都放入其中
      // 这样在组件上监听的事件就是 input 元素的事件了
    	computed: {
    		myListeners() {
    			return {
            ...this.$listeners,
            // 其他想要监听的事件
            // ...
    			}
    		}
      },
    });
    Vue.component('custom-checkbox', {
    	// 默认情况下v-model会把实例的属性绑定到value，event为input
    	// model字段允许自定义组件在使用v-model时定制绑定的属性prop和event
    	model: {
    		prop: 'checked',
    		event: 'change',
    	},
    	props: {
    		checked: Boolean,
    		// value 可以用作其他用途了
    		value: String
    	},
    	template: `
        <label>
          <input
            type="checkbox"
            :checked="checked"
            v-on:change="$emit('change', $event.target.checked)" />
          {{value}}
        </label>`
    })
    let customInputDemo = new Vue({
    	el: '#custom-input-demo',
    	data: {
    		label: 'input:',
    		searchText: '',
    		foo: true,
    	}
    })
  </script>

  <!-- slot插槽分发内容 -->
  <div id="alert-box-demo">
    <alert-box>
      <!-- v-slot指令 v-slot:slot-name="slotProps" -->
      <!-- slot-name 为具名插槽的 name 可以指定为 default 分配给默认插槽 -->
      <!-- 插槽名可以使用动态属性 v-slot:[dynamicSlotName] -->
      <!-- ="slotProps" 可选，在想要访问组件内作用域提供的属性时使用，推荐使用解构赋值语法 -->
      <!-- v-slot 指令只能使用在 template 标签。只有一种情况例外：当只有默认插槽时，v-slot 可以写在组件标签上 -->
      <!-- <alert-box v-slot="slotProps">{{ slotProps.user.lastName }}</alert-box> -->
      <!-- 提供了缩写形式 v-slot: 缩写为 # 并且 # 后必须提供插槽名 #default -->
      <template v-slot:my-slot="{ user }">
        <span>{{ `${user.firstName} ${user.lastName}, Something bad happened.` }}</span>
      </template>
    </alert-box>
  </div>
  <script>
    // 插槽可以有多个，这时需要为 slot 指定 name，
    Vue.component('alert-box', {
      data: function() {
        return {
          user: {
            firstName: 'dabei',
            lastName: 'Wen'
          }
        }
      },
      // 有时需要在组件外访问组件内的数据，例如 user
      // 可以将 user 用 v-bind 绑定到 slot
      // 这样就可以在组件外使用 v-slot:slot-name="slotProps" 指令时，使用 slotProps.user 访问到
      // 或者使用解构语法 v-slot:slot-name="{ user }"
      // 甚至可以使用解构重命名或者默认值(防止组件没有提供作用域属性)：
      // v-slot:slot-name="{ user: myUser = { firstName: 'default', lastName: 'default' } }"
    	template: `
        <div class="demo-alert-box">
          <strong>Error!</strong>
          <slot name="my-slot" :user="user">default contents</slot>
        </div>`
    });
    let alertBoxDemo = new Vue({
    	el: '#alert-box-demo'
    });
  </script>


  <!-- 动态组件 -->
  <!-- <component :is="currentTabComponent"></component> 来绑定显示哪个组件 -->
  <!-- 可以用 keep-alive 标签包裹 component 标签，这样失活的组件会被缓存，切换回来不会重构 -->
  <!-- keep-alive 包裹的组件必须有 name -->
  <div id="dynamic-component-demo">
    <button v-for="tab in tabs" @click="currentTab=tab">{{tab}}</button>
    <component v-bind:is="currentTabComponent"></component>
  </div>
  <script>
    let dynamicComponentDemo = new Vue({
    	el: '#dynamic-component-demo',
    	data: {
    		currentTab: 'Home',
    		tabs: ['Home', 'Posts', 'Archive']
    	},
    	computed: {
    		currentTabComponent: function() {
    			return 'tab-' + this.currentTab.toLowerCase();
    		}
    	},
    	components: {
    		'tab-home': {
    			template: '<p>Home component</p>'
    		},
    		'tab-posts': {
    			template: '<p>Posts component</p>'
    		},
    		'tab-archive': {
    			template: '<p>Archive component</p>'
    		}
    	}
    });
  </script>


  <script>

    // provide 和 inject 实现依赖注入。
    // provide 指定我们想要提供给后代组件的数据/方法
    // provide: function() {
    // 	return {
    // 		getMap: this.getMap
    // 	}
    // }
    // 在后代组件里可以用 inject 来接收指定的属性
    // inject: ['getMap']
    // 依赖注入是非响应式的，加深了组件之间的耦合，更推荐使用 Vuex


    // 在 Vue 实例中可以手动监听事件
    // 通过 vm.$on(eventName, eventHandler) 侦听一个事件
    // 通过 vm.$once(eventName, eventHandler) 一次性侦听一个事件
    // 通过 vm.$off(eventName, eventHandler) 停止侦听一个事件
    // 集成一个第三方库，销毁代码可以用$once('hook:beforeDestroy', func)
    // mounted: function() {
    // 	// Pikaday 是一个第三方日期选择器的库
    // 	var picker = new Pikaday({
    // 		field: this.$refs.input,
    // 		format: 'YYYY-MM-DD'
    // 	})
    // 	// 在组件被销毁之前，
    // 	// 也销毁这个日期选择器。
    // 	this.$once('hook:beforeDestroy', function() {
    // 		picker.destroy()
    // 	})
    // }


    // 组件可以递归引用，通过实例中的 name 选项，注意设定递归终止条件
    // 组件之间可以循环调用，如果使用全局注册组件，可以自动解除悖论；使用webapck模块导入时，会报错组件未定义
    // 可以在生命周期钩子beforeCreate去注册子组件来解决
    // beforeCreate: function() {
    //   this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default;
    // }
    // 或者使用 webpack 异步 import
    // components: {
    //   TreeFolderContents: () => import('.tree-folder-contents.vue');
    // }

    // 强制更新
    // vm.$forceUpdate() 只影响本组件和插入插槽的子组件

  </script>


</body>

</html>
